<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>promise</title>
	<style>
		body{font-size:13px}
		h1,h2,h3,h4,h5,div,p,dt,dd{padding:0;margin:0}
		h1{font-size:17px}
		h2{margin:15px 0 10px;font-size:15px}
		dt{margin-top:10px;font-weight:bold}
	</style>
	<script>
        aa : function() {
            var pp = $.Deferred();  // 비동기 준비

            setTimeout(function() {
                pp.resolve(3);  // pp의 프로미스가 완료되면~~
                alert(2);  // 3번째로 2출력
            }, 1000);

            return pp;  // pp.promise() 랑 같음.
        },

        bb : function() {
            var promise = this.aa();

            promise.then(function(ccc) {  // ccc 는 프모미스 완료된 3을 받아옴.
                alert(ccc);  // 1번째로 3출력

                return $.Deferred().resolve(6);
            })
            .then(function(kk) {  // bb() 를 리던 받아 프로미스 완료된 6을 kk에 넣는다.
                alert(kk); // 2번째로 6출력
            })
        }
        bb();
	</script>

	<script>
        // then()의 두 번째 인자로는 감지하지 못하는 오류
        function getData() {
            return new Promise(function (resolve, reject) {
                resolve('hi');
            });
        }

        getData().then(function (result) {
            console.log(result);
            throw new Error("Error in then()"); // Uncaught (in promise) Error: Error in then()
        }, function (err) {
            console.log('then error : ', err);
        });
        /*
        getData() 함수의 프로미스에서 resolve() 메서드를 호출하여 정상적으로 로직을 처리했지만,
        then()의 첫 번째 콜백 함수 내부에서 오류가 나는 경우 오류를 제대로 잡아내지 못합니다.
        따라서 코드를 실행하면 주석과 같은 오류가 납니다.
         */
	</script>
</head>
<body>
<h1>promise</h1>
<p>Promise는 비동기 조작의 최종 완료 또는 실패를 나타내는 객체입니다.</p>

<h2>methods</h2>
<dl>
	<dt>promise.all()</dt>
	<dd>전달된 promise 중 하나라도 rejected 되면 .all은 다른 promise가 남았는지 여부에 관계없이 다른 모든 promise를 버리고 문제가 되는 값과 함께 reject한다.</dd>
	<dd>배열 내의 모든 값이 resolve할 때까지 기다린다.</dd>
	<dd>하나라도 reject되면 즉시 거절한다. 즉 4개의 promise를 가지고 있고 그중 하나만 reject 되면 즉시 거절.</dd>
</dl>
<dl>
	<dt>promise.catch()</dt>
	<dd>promise 반환하여 거부된 경우만 실행.</dd>
	<dd>거부 이유는 파라미터로 제공</dd>
	<dd>promise는 비동기 콜백 내에 발상한 오류를 잡을 수 없어서 가급적 에러 처리는 catch()로 한다.</dd>
</dl>
<dl>
	<dt>promise.finally()</dt>
	<dd>promise 반환하여 성공여부와 상관없이 무조건 한번은 실행된다.</dd>
	<dd>promise는 비동기 콜백 내에 발상한 오류를 잡을 수 없어서 가급적 에러 처리는 catch()로 한다.</dd>
	<dd>이것은 then(), catch() 핸들러에서 코드 중복을 피하게 한다.</dd>
</dl>
<dl>
	<dt>promise.then()</dt>
	<dd>promise 를 반환하고 두개의 콜백 함수를 인수로 받는다.</dd>
	<dd>첫번째 파마리터는 수행값, 두번째 파라미터는 거부 이유</dd>
	<dd>then, catch 메서드는 promise를 리턴 하기때문에 chaining이 가능하다.</dd>
</dl>
<dl>
	<dt>promise.race()</dt>
	<dd>promise 를 반환하고 race 함수는 최초 통과 처리한 프로미스와 같은 식으로 처리되는 Promise를 반환합니다. 결정(resolve) 또는 거부합니다, 어느 쪽이 먼저 일어나든.</dd>
	<dd>성공 또는 실패 둘중에 1개가 먼저 응답이 오면 다른 1개는 호출되지 않는다.</dd>
</dl>
<dl>
	<dt>promise.reject()</dt>
	<dd>promise 를 반환하고 오류를 잡기 위해 사용.</dd>
	<dd>파마리터를(reason) instanceof Error 에 유용</dd>
	<dd>성공 또는 실패 둘중에 1개가 먼저 응답이 오면 다른 1개는 호출되지 않는다.</dd>
</dl>
<dl>
	<dt>promise.resolve()</dt>
	<dd>promise.then 객체를 반환</dd>
</dl>

<h1>jQuery Deferred Object</h1>
<p>jQuery Deferred는 각각의 비동기식 처리에 Promise 객체를 연계하여 그 상태를 전파하는 것으로 promise를 구현한 jQuery 객체이다. 브라우저 호환성과 편의성을 고려하여 만든 Promise 모듈이라고 생각하면 무리가 없을 듯하다.</p>

<h2>Deferred</h2>
<ul>
	<li>Deferred() 여러 콜백을 콜백 대기열에 등록하고, 콜백 대기열을 호출하고, 동기 또는 비동기 함수의 성공 또는 실패 상태를 중계하는 메소드로 체인 가능 유틸리티 객체를 반환하는 팩토리 함수입니다.</li>
	<li>
		성공시 done(), 실패시 fail() 담고있다.
	</li>
	<li>then()은 성공, 실패의 콜백함수를 한번에 기술할 수 있다.</li>
	<li>$.when() 복수의 비동기 처리를 병렬로 처리할 수 있다. 하나라도 실패하면 reject 반환한다.</li>
	<li>progress() 진행률 알림.</li>
	<li>.promise 는 deferred의 promise 반환</li>
	<li>.pipe()필터 및 체인화 하는 유틸</li>
	<li>.state()객체의 현재 상태</li>
</ul>
</body>
</html>

